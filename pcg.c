/*******************************************************************************
* Copyright (C) 2019-2024 Maxim Integrated Products, Inc., All rights Reserved.
*
* This software is protected by copyright laws of the United States and
* of foreign countries. This material may also be protected by patent laws
* and technology transfer regulations of the United States and of foreign
* countries. This software is furnished under a license agreement and/or a
* nondisclosure agreement and may only be used or reproduced in accordance
* with the terms of those agreements. Dissemination of this information to
* any party or parties not specified in the license agreement and/or
* nondisclosure agreement is expressly prohibited.
*
* The above copyright notice and this permission notice shall be included
* in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
* OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*
* Except as contained in this notice, the name of Maxim Integrated
* Products, Inc. shall not be used except as stated in the Maxim Integrated
* Products, Inc. Branding Policy.
*
* The mere transfer of this software does not imply any licenses
* of trade secrets, proprietary technology, copyrights, patents,
* trademarks, maskwork rights, or any other form of intellectual
* property whatsoever. Maxim Integrated Products, Inc. retains all
* ownership rights.
*******************************************************************************/

// pcg
// This file was @generated by ai8xize.py --board-name FTHR_RevA --overwrite --sample-input ../ai8x-training/sample_pcg.npy --test-dir sdk/Examples/MAX78000/CNN --prefix pcg --checkpoint-file ../ai8x-training/qat_best-q.pth.tar --config-file ../ai8x-training/pcg.yaml --fifo --device MAX78000 --compact-data --mexpress --timer 0 --display-checkpoint --verbose
#include "pcg.h"
#include "file_arrays.h"
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
//#include "testdata.h" // Test data file include
#include "sampleoutput.h"
#include "sdhc.h"
#include "mxc_device.h"
#include "mxc_delay.h"
#include "nvic_table.h"
#include "pb.h"
#include "board.h"
#include "gpio.h"
#include "ff.h"

/***** Globals *****/
int max_class;
//FATFS *fs; //FFat Filesystem Object
//FATFS fs_obj;
//FIL file; //FFat File Object
//FRESULT err; //FFat Result (Struct)
//FILINFO fno; //FFat File Information Object
//DIR dir; //FFat Directory Object
//TCHAR *FF_ERRORS[20];
//BYTE work[4096];
//
//DWORD clusters_free = 0, sectors_free = 0, sectors_total = 0, volume_sn = 0;
//UINT bytes_written = 0, bytes_read = 0, mounted = 0;
//
////static char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.-#'?!";
//TCHAR message[MAXLEN], directory[MAXLEN], cwd[MAXLEN], filename[MAXLEN], volume_label[24],
//    volume = '0';
//mxc_gpio_cfg_t SDPowerEnablePin = { MXC_GPIO1, MXC_GPIO_PIN_12, MXC_GPIO_FUNC_OUT,
//                                    MXC_GPIO_PAD_NONE, MXC_GPIO_VSSEL_VDDIO };

volatile uint32_t cnn_time; // Stopwatch

void LCD_Command(uint8_t cmd);
void LCD_Init(void);
void LCD_String(char *str);
void LCD_Data(uint8_t data);
int lcd(void);

void fail(void)
{
  printf("\n*** FAIL ***\n\n");
  while (1);
}

// Data input: CHW 1x47x39 (1833 bytes):
//TCHAR* f_gets (
//	TCHAR* buff,	/* Pointer to the buffer to store read string */
//	int len,		/* Size of string buffer (items) */
//	FIL* fp			/* Pointer to the file object */
//)
//{
//	int nc = 0;
//	TCHAR *p = buff;
//	BYTE s[4];
//	UINT rc;
//	DWORD dc;
//#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE <= 2
//	WCHAR wc;
//#endif
//#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE == 3
//	UINT ct;
//#endif
//
//#if FF_USE_LFN && FF_LFN_UNICODE			/* With code conversion (Unicode API) */
//	/* Make a room for the character and terminator  */
//	if (FF_LFN_UNICODE == 1) len -= (FF_STRF_ENCODE == 0) ? 1 : 2;
//	if (FF_LFN_UNICODE == 2) len -= (FF_STRF_ENCODE == 0) ? 3 : 4;
//	if (FF_LFN_UNICODE == 3) len -= 1;
//	while (nc < len) {
//#if FF_STRF_ENCODE == 0				/* Read a character in ANSI/OEM */
//		f_read(fp, s, 1, &rc);		/* Get a code unit */
//		if (rc != 1) break;			/* EOF? */
//		wc = s[0];
//		if (dbc_1st((BYTE)wc)) {	/* DBC 1st byte? */
//			f_read(fp, s, 1, &rc);	/* Get 2nd byte */
//			if (rc != 1 || !dbc_2nd(s[0])) continue;	/* Wrong code? */
//			wc = wc << 8 | s[0];
//		}
//		dc = ff_oem2uni(wc, CODEPAGE);	/* Convert ANSI/OEM into Unicode */
//		if (dc == 0) continue;		/* Conversion error? */
//#elif FF_STRF_ENCODE == 1 || FF_STRF_ENCODE == 2 	/* Read a character in UTF-16LE/BE */
//		f_read(fp, s, 2, &rc);		/* Get a code unit */
//		if (rc != 2) break;			/* EOF? */
//		dc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
//		if (IsSurrogateL(dc)) continue;	/* Broken surrogate pair? */
//		if (IsSurrogateH(dc)) {		/* High surrogate? */
//			f_read(fp, s, 2, &rc);	/* Get low surrogate */
//			if (rc != 2) break;		/* EOF? */
//			wc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
//			if (!IsSurrogateL(wc)) continue;	/* Broken surrogate pair? */
//			dc = ((dc & 0x3FF) + 0x40) << 10 | (wc & 0x3FF);	/* Merge surrogate pair */
//		}
//#else	/* Read a character in UTF-8 */
//		f_read(fp, s, 1, &rc);		/* Get a code unit */
//		if (rc != 1) break;			/* EOF? */
//		dc = s[0];
//		if (dc >= 0x80) {			/* Multi-byte sequence? */
//			ct = 0;
//			if ((dc & 0xE0) == 0xC0) {	/* 2-byte sequence? */
//				dc &= 0x1F; ct = 1;
//			}
//			if ((dc & 0xF0) == 0xE0) {	/* 3-byte sequence? */
//				dc &= 0x0F; ct = 2;
//			}
//			if ((dc & 0xF8) == 0xF0) {	/* 4-byte sequence? */
//				dc &= 0x07; ct = 3;
//			}
//			if (ct == 0) continue;
//			f_read(fp, s, ct, &rc);	/* Get trailing bytes */
//			if (rc != ct) break;
//			rc = 0;
//			do {	/* Merge the byte sequence */
//				if ((s[rc] & 0xC0) != 0x80) break;
//				dc = dc << 6 | (s[rc] & 0x3F);
//			} while (++rc < ct);
//			if (rc != ct || dc < 0x80 || IsSurrogate(dc) || dc >= 0x110000) continue;	/* Wrong encoding? */
//		}
//#endif
//		/* A code point is avaialble in dc to be output */
//
//		if (FF_USE_STRFUNC == 2 && dc == '\r') continue;	/* Strip \r off if needed */
//#if FF_LFN_UNICODE == 1	|| FF_LFN_UNICODE == 3	/* Output it in UTF-16/32 encoding */
//		if (FF_LFN_UNICODE == 1 && dc >= 0x10000) {	/* Out of BMP at UTF-16? */
//			*p++ = (TCHAR)(0xD800 | ((dc >> 10) - 0x40)); nc++;	/* Make and output high surrogate */
//			dc = 0xDC00 | (dc & 0x3FF);		/* Make low surrogate */
//		}
//		*p++ = (TCHAR)dc; nc++;
//		if (dc == '\n') break;	/* End of line? */
//#elif FF_LFN_UNICODE == 2		/* Output it in UTF-8 encoding */
//		if (dc < 0x80) {	/* Single byte? */
//			*p++ = (TCHAR)dc;
//			nc++;
//			if (dc == '\n') break;	/* End of line? */
//		} else if (dc < 0x800) {	/* 2-byte sequence? */
//			*p++ = (TCHAR)(0xC0 | (dc >> 6 & 0x1F));
//			*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
//			nc += 2;
//		} else if (dc < 0x10000) {	/* 3-byte sequence? */
//			*p++ = (TCHAR)(0xE0 | (dc >> 12 & 0x0F));
//			*p++ = (TCHAR)(0x80 | (dc >> 6 & 0x3F));
//			*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
//			nc += 3;
//		} else {					/* 4-byte sequence */
//			*p++ = (TCHAR)(0xF0 | (dc >> 18 & 0x07));
//			*p++ = (TCHAR)(0x80 | (dc >> 12 & 0x3F));
//			*p++ = (TCHAR)(0x80 | (dc >> 6 & 0x3F));
//			*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
//			nc += 4;
//		}
//#endif
//	}
//
//#else			/* Byte-by-byte read without any conversion (ANSI/OEM API) */
//	len -= 1;	/* Make a room for the terminator */
//	while (nc < len) {
//		f_read(fp, s, 1, &rc);	/* Get a byte */
//		if (rc != 1) break;		/* EOF? */
//		dc = s[0];
//		if (FF_USE_STRFUNC == 2 && dc == '\r') continue;
//		*p++ = (TCHAR)dc; nc++;
//		if (dc == '\n') break;
//	}
//#endif
//
//	*p = 0;		/* Terminate the string */
//	return nc ? buff : 0;	/* When no data read due to EOF or error, return with error. */
//}

static uint32_t input_0[459];
int readFromSD(int num) {
    FATFS fs;
    FIL file;
    FRESULT err;
    //UINT bytes_read;
    char line[9216];  // Large enough for one line
    int index = 0;
    char *token;

    if ((err = f_mount(&fs, "", 1)) != FR_OK) {
        printf("Error mounting SD card\n");
        return err;
    }

    if ((err = f_open(&file,"testdata.h", FA_READ)) != FR_OK) {
        printf("Error opening file %s\n",header_files[num]);
        f_mount(NULL, "", 0);
        return err;
    }

    f_gets(line, sizeof(line), &file);
    token = strtok(line, ",");
    while(token != NULL && index < 459) {
        sscanf(token, "0x%x", &input_0[index++]);
        //printf("Reading..%d\n",index-1);
        //printf("0x%08X\n",input_0[index-1]);
        token = strtok(NULL, ",");
    }


    f_close(&file);
    f_mount(NULL, "", 0);
    return 0;
}

void printdata(void)
{
	for(int i = 0; i < sizeof(input_0)/sizeof(input_0[0]); i++) {
	  printf("Printing.....%d\n0x%08X\n",i, input_0[i]);
	}
}

//static const uint32_t input_0[] = SAMPLE_INPUT_0;
void load_input(void)
{
  // This function loads the sample data input -- replace with actual data

  int i;
  const uint32_t *in0 = input_0;

  for (i = 0; i < 459; i++) {
    // Remove the following line if there is no risk that the source would overrun the FIFO:
    while (((*((volatile uint32_t *) 0x50000004) & 1)) != 0); // Wait for FIFO 0
    *((volatile uint32_t *) 0x50000008) = *in0++; // Write FIFO 0
  }
}

// Expected output of layer 3 (linear) for pcg given the sample input (known-answer test)
// Delete this function for production code
//static const uint32_t sample_output[] = SAMPLE_OUTPUT;
int check_output(void)
{
/**  int i;
  uint32_t mask, len;
  volatile uint32_t *addr;
  const uint32_t *ptr = sample_output;

  while ((addr = (volatile uint32_t *) *ptr++) != 0) {
    mask = *ptr++;
    len = *ptr++;
    for (i = 0; i < len; i++)
      if ((*addr++ & mask) != *ptr++) {
        printf("Data mismatch (%d/%d) at address 0x%08x: Expected 0x%08x, read 0x%08x.\n",
               i + 1, len, addr - 1, *(ptr - 1), *(addr - 1) & mask);
        return CNN_FAIL;
      }
  }**/

  return CNN_OK;
}

static int32_t ml_data[CNN_NUM_OUTPUTS];
// Define constants
#define NUM_CLASSES 5
#define CNN_NUM_OUTPUTS 3
#define ML_DATA_SIZE 6
#define SCALING_FACTOR (1 << 24)

// Structure to hold CNN results
typedef struct {
    uint16_t probabilities[ML_DATA_SIZE];
    int max_class;
    uint16_t max_value;
} CNN_Results;

// Function declarations
static void initialize_system(void);
static void process_cnn_output(uint32_t* ml_data, CNN_Results* results);
static void print_results(const CNN_Results* results);

// Optimized main CNN function
char* pcg_main(int num) {
    static const char* class_names[NUM_CLASSES] = {"AS", "MR", "MS", "MVP", "N"};
    CNN_Results results = {0};
    uint32_t ml_data[CNN_NUM_OUTPUTS];

    // Initialize system
    initialize_system();

    // CNN Processing
    if (cnn_init() != CNN_OK) {
        printf("Error: CNN initialization failed\n");
        return NULL;
    }

    // Load CNN parameters
    cnn_load_weights();
    cnn_load_bias();
    cnn_configure();

    // Start CNN processing
    cnn_start();

    // Load input data
    if (readFromSD(num) != 0) {
        printf("Error: Failed to read from SD\n");
        return NULL;
    }

    load_input();

    // Wait for CNN processing
    while (cnn_time == 0) {
        MXC_LP_EnterSleepMode();
    }

    // Check and unload output
    if (check_output() != CNN_OK) {
        printf("Error: CNN output check failed\n");
        return NULL;
    }

    cnn_unload(ml_data);

    // Process CNN output
    process_cnn_output(ml_data, &results);

    // Print results
    print_results(&results);

    // Display on LCD
    if (lcd() != 0) {
        printf("Warning: LCD display failed\n");
        printf("wngoqiriobgiwigbribgiobrewiogbirbgiorbigvbrebkvnfekbvikerbnblrn");
    }

    // Print timing information if enabled
    #ifdef CNN_INFERENCE_TIMER
    printf("Approximate data loading and inference time: %u us\n\n", cnn_time);
    #endif

    // Cleanup
    cnn_disable();

    return (char*)class_names[results.max_class];
}

// Initialize system components
static void initialize_system(void) {
    // Enable cache
    MXC_ICC_Enable(MXC_ICC0);

    // Configure system clock
    MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
    SystemCoreClockUpdate();

    printf("Initializing system...\n");
    MXC_Delay(SEC(2));

    // Enable CNN with appropriate clock settings
    cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

    printf("\n*** CNN Inference Test pcg ***\n");
}

// Process CNN output data
static void process_cnn_output(uint32_t* ml_data, CNN_Results* results) {
    // Extract 16-bit values from ml_data
    results->probabilities[0] = (ml_data[0] & 0xFFFF);
    results->probabilities[1] = (ml_data[0] >> 16) & 0xFFFF;
    results->probabilities[2] = (ml_data[1] & 0xFFFF);
    results->probabilities[3] = (ml_data[1] >> 16) & 0xFFFF;
    results->probabilities[4] = (ml_data[2] & 0xFFFF);
    results->probabilities[5] = (ml_data[2] >> 16) & 0xFFFF;

    // Find maximum probability
    results->max_value = results->probabilities[0];
    results->max_class = 0;

    for (int i = 1; i < ML_DATA_SIZE; i++) {
        if (results->probabilities[i] > results->max_value) {
            results->max_value = results->probabilities[i];
            results->max_class = i;
        }
    }
}

// Print classification results
static void print_results(const CNN_Results* results) {
    static const char* class_names[NUM_CLASSES] = {"AS", "MR", "MS", "MVP", "N"};

    printf("Classification Results:\n");
    printf("Probabilities: [%02x, %02x, %02x, %02x, %02x]\n",
           results->probabilities[0], results->probabilities[1],
           results->probabilities[2], results->probabilities[3],
           results->probabilities[4]);

    printf("Maximum probability: 0x%04X\n", results->max_value);
    printf("The patient has max probability of having Class: %s\n",
           class_names[results->max_class]);
    int LEDcount=max_class;
    while(LEDcount>0)
    {
    	LED_On(LED1);
    	MXC_Delay(500000);
    	LED_Off(LED1);
    	MXC_Delay(500000);
    	LEDcount--;
    }
    printf("\n*** PASS ***\n\n");
    printf("Check display for output\n");
}

//char* pcg_main(int num)
//{
//  MXC_ICC_Enable(MXC_ICC0); // Enable cache
//
//  // Switch to 100 MHz clock
//  MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
//  SystemCoreClockUpdate();
//
//  printf("Waiting...\n");
//
//  // DO NOT DELETE THIS LINE:
//  MXC_Delay(SEC(2)); // Let debugger interrupt if needed
//
//  // Enable peripheral, enable CNN interrupt, turn on CNN clock
//  // CNN clock: APB (50 MHz) div 1
//  cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);
//
//  printf("\n*** CNN Inference Test pcg ***\n");
//
//  cnn_init(); // Bring state machine into consistent state
//  cnn_load_weights(); // Load kernels
//  cnn_load_bias();
//  cnn_configure(); // Configure state machine
//  cnn_start(); // Start CNN processing
//  readFromSD(num);
//  //printdata();
//  load_input(); // Load data input via FIFO
//
//  while (cnn_time == 0)
//    MXC_LP_EnterSleepMode(); // Wait for CNN
//
//
//  if (check_output() != CNN_OK) fail();
//  cnn_unload((uint32_t *) ml_data);
//
//  uint16_t ml_data_updated[6];
//
//  // Split and store each element of ml_data into two 16-bit values
//      ml_data_updated[0] = (ml_data[0] & 0xFFFF);           // Lower 16 bits of the first element
//      ml_data_updated[1] = (ml_data[0] >> 16) & 0xFFFF;     // Upper 16 bits of the first element
//      ml_data_updated[2] = (ml_data[1] & 0xFFFF);           // Lower 16 bits of the second element
//      ml_data_updated[3] = (ml_data[1] >> 16) & 0xFFFF;     // Upper 16 bits of the second element
//      ml_data_updated[4] = (ml_data[2] & 0xFFFF);           // Lower 16 bits of the third element
//      ml_data_updated[5] = (ml_data[2] >> 16) & 0xFFFF;     // Upper 16 bits of the third element
//
//      // Print the results
//     // printf("ml_data_updated: [%02x, %02x, %02x, %02x, %02x]\n",
//       //      ml_data_updated[0], ml_data_updated[1],
//         //    ml_data_updated[2], ml_data_updated[3], ml_data_updated[4]);
//
//
//  // Print the contents of ml_data
//   //printf("CNN Output Data:\n");
//   //for (int i = 0; i < CNN_NUM_OUTPUTS; i++)
//   //printf("ml_data[%d] = 0x%08X\n", 0, (unsigned int)ml_data[0]);
//   //printf("ml_data[%d] = 0x%08X\n", 1, (unsigned int)ml_data[1]);
//   //printf("ml_data[%d] = 0x%08X\n", 2, (unsigned int)ml_data[2]);
//	//printf("Classification Results:\n");
//	//printf("Class 0: %.2f\n", (float)ml_data[0] / (1 << 24)); // Scale by 2^24
//	//printf("Class 1: %.2f\n", (float)ml_data[1] / (1 << 24));
//	//printf("Class 2: %.2f\n", (float)ml_data[2] / (1 << 24));
//  printf("Classification Results:\n");
//  printf("ml_data_updated: [%02x, %02x, %02x, %02x, %02x]\n",
//               ml_data_updated[0], ml_data_updated[1],
//               ml_data_updated[2], ml_data_updated[3], ml_data_updated[4]);
//
//  // Find the maximum value in ml_data_updated
//      uint16_t max_value = ml_data_updated[0];
//
//      for (int i = 1; i < 6; i++) {
//          if (ml_data_updated[i] > max_value) {
//              max_value = ml_data_updated[i];
//              max_class=i;
//          }
//      }
//
//      char* classes[5]={"AS","MR","MS","MVP","N"};
//      // Print the maximum value
//      printf("Maximum value in ml_data_updated: 0x%04X\n", max_value);
//      printf("The patient has max probability of having Class: %s",classes[max_class]);
//
//
//      printf("\n*** PASS ***\n\n");
//
//      lcd();
//      printf("Check display for output\n");
//
//#ifdef CNN_INFERENCE_TIMER
//  printf("Approximate data loading and inference time: %u us\n\n", cnn_time);
//#endif
//
//  cnn_disable(); // Shut down CNN clock, disable peripheral
//
//
//  return classes[max_class];
//}


//LCD Starts here

//Pin definitions
//RS
#define MXC_GPIO_PORT_OUT1_1 MXC_GPIO1
#define MXC_GPIO_PIN_OUT1_1 MXC_GPIO_PIN_1
//Enable
#define MXC_GPIO_PORT_OUT1_0 MXC_GPIO1
#define MXC_GPIO_PIN_OUT1_0 MXC_GPIO_PIN_0
//D4
#define MXC_GPIO_PORT_OUT2_6 MXC_GPIO2
#define MXC_GPIO_PIN_OUT2_6 MXC_GPIO_PIN_6
//D5
#define MXC_GPIO_PORT_OUT2_7 MXC_GPIO2
#define MXC_GPIO_PIN_OUT2_7 MXC_GPIO_PIN_7
//D6
#define MXC_GPIO_PORT_OUT1_6 MXC_GPIO1
#define MXC_GPIO_PIN_OUT1_6 MXC_GPIO_PIN_6
//D7
#define MXC_GPIO_PORT_OUT0_19 MXC_GPIO0
#define MXC_GPIO_PIN_OUT0_19 MXC_GPIO_PIN_19


int lcd(void)
{
	// Configure pins
	mxc_gpio_cfg_t gpio_out1, gpio_out2, gpio_out3, gpio_out4, gpio_out5, gpio_out6;

	// Pin 1.1
	gpio_out1.port = MXC_GPIO_PORT_OUT1_1;
	gpio_out1.mask = MXC_GPIO_PIN_OUT1_1;
	gpio_out1.pad = MXC_GPIO_PAD_NONE;
	gpio_out1.func = MXC_GPIO_FUNC_OUT;
	gpio_out1.vssel = MXC_GPIO_VSSEL_VDDIO;
	gpio_out1.drvstr = MXC_GPIO_DRVSTR_0;
	MXC_GPIO_Config(&gpio_out1);

	// Pin 1.0
	gpio_out2.port = MXC_GPIO_PORT_OUT1_0;
	gpio_out2.mask = MXC_GPIO_PIN_OUT1_0;
	gpio_out2.pad = MXC_GPIO_PAD_NONE;
	gpio_out2.func = MXC_GPIO_FUNC_OUT;
	gpio_out2.vssel = MXC_GPIO_VSSEL_VDDIO;
	gpio_out2.drvstr = MXC_GPIO_DRVSTR_0;
	MXC_GPIO_Config(&gpio_out2);

	// Pin 2.6
	gpio_out3.port = MXC_GPIO_PORT_OUT2_6;
	gpio_out3.mask = MXC_GPIO_PIN_OUT2_6;
	gpio_out3.pad = MXC_GPIO_PAD_NONE;
	gpio_out3.func = MXC_GPIO_FUNC_OUT;
	gpio_out3.vssel = MXC_GPIO_VSSEL_VDDIO;
	gpio_out3.drvstr = MXC_GPIO_DRVSTR_0;
	MXC_GPIO_Config(&gpio_out3);

	// Pin 2.7
	gpio_out4.port = MXC_GPIO_PORT_OUT2_7;
	gpio_out4.mask = MXC_GPIO_PIN_OUT2_7;
	gpio_out4.pad = MXC_GPIO_PAD_NONE;
	gpio_out4.func = MXC_GPIO_FUNC_OUT;
	gpio_out4.vssel = MXC_GPIO_VSSEL_VDDIO;
	gpio_out4.drvstr = MXC_GPIO_DRVSTR_0;
	MXC_GPIO_Config(&gpio_out4);

	// Pin 1.6
	gpio_out5.port = MXC_GPIO_PORT_OUT1_6;
	gpio_out5.mask = MXC_GPIO_PIN_OUT1_6;
	gpio_out5.pad = MXC_GPIO_PAD_NONE;
	gpio_out5.func = MXC_GPIO_FUNC_OUT;
	gpio_out5.vssel = MXC_GPIO_VSSEL_VDDIO;
	gpio_out5.drvstr = MXC_GPIO_DRVSTR_0;
	MXC_GPIO_Config(&gpio_out5);

	// Pin 0.19
	gpio_out6.port = MXC_GPIO_PORT_OUT0_19;
	gpio_out6.mask = MXC_GPIO_PIN_OUT0_19;
	gpio_out6.pad = MXC_GPIO_PAD_NONE;
	gpio_out6.func = MXC_GPIO_FUNC_OUT;
	gpio_out6.vssel = MXC_GPIO_VSSEL_VDDIO;
	gpio_out6.drvstr = MXC_GPIO_DRVSTR_0;
	MXC_GPIO_Config(&gpio_out6);

	LCD_Init();

	switch(max_class)
	{
	case 0: LCD_Command(0x80);  // Set cursor to first line
            LCD_String("Class:1");
            LCD_Command(0xC0);  // Set cursor to second line
            LCD_String("Complete");
            break;

	case 1: LCD_Command(0x80);  // Set cursor to first line
	        LCD_String("Class:2");
	        LCD_Command(0xC0);  // Set cursor to second line
	        LCD_String("Complete");
	        break;

	case 2: LCD_Command(0x80);  // Set cursor to first line
	        LCD_String("Class:3");
	        LCD_Command(0xC0);  // Set cursor to second line
	        LCD_String("Complete");
	        break;

	case 3: LCD_Command(0x80);  // Set cursor to first line
	        LCD_String("Class:4");
	        LCD_Command(0xC0);  // Set cursor to second line
	        LCD_String("Complete");
	        break;

	case 4: LCD_Command(0x80);  // Set cursor to first line
	        LCD_String("Class:5");
	        LCD_Command(0xC0);  // Set cursor to second line
	        LCD_String("Complete");
	        break;



	}
	return 0;
}

void LCD_Init(void) {
    // Wait for power up (>40ms)
    MXC_TMR_Delay(MXC_TMR0, 50000);  // 50ms delay

    // Function Set: 4-bit mode, 2 lines, 5x7 font
    // First send upper nibble only (0x3)
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_1, MXC_GPIO_PIN_OUT1_1);  // RS = 0 for command
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 0

    // Send 0x3 three times (initialization sequence)
    for(int i = 0; i < 3;i++) {
        MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 1
        // Set data pins for 0x3
        MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_6, MXC_GPIO_PIN_OUT2_6);   // D7 = 0
        MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_7, MXC_GPIO_PIN_OUT2_7);   // D6 = 0
        MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_6, MXC_GPIO_PIN_OUT1_6);   // D5 = 1
        MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT0_19, MXC_GPIO_PIN_OUT0_19);   // D4 = 1

        MXC_TMR_Delay(MXC_TMR0, 1);  // Small delay
        MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 0
        MXC_TMR_Delay(MXC_TMR0, 5000);  // 5ms delay
    }

    // Now set 4-bit mode
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 1
    // Send 0x2
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT2_6, MXC_GPIO_PIN_OUT2_6);   // D7 = 0
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT2_7, MXC_GPIO_PIN_OUT2_7);   // D6 = 0
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_6, MXC_GPIO_PIN_OUT1_6);   // D5 = 1
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT0_19, MXC_GPIO_PIN_OUT0_19);   // D4 = 0

    MXC_TMR_Delay(MXC_TMR0, 1);
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 0
    MXC_TMR_Delay(MXC_TMR0, 100);

    // Function Set: 4-bit mode, 2 lines, 5x7 font (0x28)
    LCD_Command(0x28);

    // Display OFF (0x08)
    LCD_Command(0x08);

    // Clear Display (0x01)
    LCD_Command(0x01);
    MXC_TMR_Delay(MXC_TMR0, 2000);  // Clear needs 1.64ms

    // Entry Mode Set: Increment, No shift (0x06)
    LCD_Command(0x06);

    // Display ON, Cursor ON, Blink ON (0x0F)
    LCD_Command(0x0F);
}

// Helper function to send command
void LCD_Command(uint8_t cmd) {
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_1, MXC_GPIO_PIN_OUT1_1);  // RS = 0 for command

    // Send upper nibble
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 1
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_6, (cmd & 0x80) ? MXC_GPIO_PIN_OUT2_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_7, (cmd & 0x40) ? MXC_GPIO_PIN_OUT2_7 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_6, (cmd & 0x20) ? MXC_GPIO_PIN_OUT1_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT0_19, (cmd & 0x10) ? MXC_GPIO_PIN_OUT0_19 : 0);
    MXC_TMR_Delay(MXC_TMR0, 1);
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 0
    MXC_TMR_Delay(MXC_TMR0, 100);

    // Send lower nibble
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 1
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_6, (cmd & 0x08) ? MXC_GPIO_PIN_OUT2_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_7, (cmd & 0x04) ? MXC_GPIO_PIN_OUT2_7 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_6, (cmd & 0x02) ? MXC_GPIO_PIN_OUT1_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT0_19, (cmd & 0x01) ? MXC_GPIO_PIN_OUT0_19 : 0);
    MXC_TMR_Delay(MXC_TMR0, 1);
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 0
    MXC_TMR_Delay(MXC_TMR0, 100);
}

void LCD_Data(uint8_t data) {
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_1, MXC_GPIO_PIN_OUT1_1);  // RS = 1 for data

    // Send upper nibble
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 1
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_6, (data & 0x80) ? MXC_GPIO_PIN_OUT2_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_7, (data & 0x40) ? MXC_GPIO_PIN_OUT2_7 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_6, (data & 0x20) ? MXC_GPIO_PIN_OUT1_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT0_19, (data & 0x10) ? MXC_GPIO_PIN_OUT0_19 : 0);
    MXC_TMR_Delay(MXC_TMR0, 1);
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 0
    MXC_TMR_Delay(MXC_TMR0, 100);

    // Send lower nibble
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 1
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_6, (data & 0x08) ? MXC_GPIO_PIN_OUT2_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT2_7, (data & 0x04) ? MXC_GPIO_PIN_OUT2_7 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT1_6, (data & 0x02) ? MXC_GPIO_PIN_OUT1_6 : 0);
    MXC_GPIO_OutSet(MXC_GPIO_PORT_OUT0_19, (data & 0x01) ? MXC_GPIO_PIN_OUT0_19 : 0);
    MXC_TMR_Delay(MXC_TMR0, 1);
    MXC_GPIO_OutClr(MXC_GPIO_PORT_OUT1_0, MXC_GPIO_PIN_OUT1_0);  // E = 0
    MXC_TMR_Delay(MXC_TMR0, 100);
}

void LCD_String(char *str) {
    while(*str) LCD_Data(*str++);
}

// To print your example
/***void print(void) {
    LCD_Command(0x80);  // Set cursor to first line
    LCD_String("class:5");

    LCD_Command(0xC0);  // Set cursor to second line
    LCD_String("complete");
}***/
/*
  SUMMARY OF OPS
  Hardware: 8,831,813 ops (8,711,056 macc; 87,989 comp; 32,768 add; 0 mul; 0 bitwise)
    Layer 0 (Fused_Conv2d_BN_ReLU_1_Conv_10): 293,280 ops (263,952 macc; 29,328 comp; 0 add; 0 mul; 0 bitwise)
    Layer 1 (Fused_Conv2d_BN_ReLU_2_Conv_8): 8,505,120 ops (8,446,464 macc; 58,656 comp; 0 add; 0 mul; 0 bitwise)
    Layer 2 (avg_pool): 32,768 ops (0 macc; 0 comp; 32,768 add; 0 mul; 0 bitwise)
    Layer 3 (linear): 645 ops (640 macc; 5 comp; 0 add; 0 mul; 0 bitwise)

  RESOURCE USAGE
  Weight memory: 5,392 bytes out of 442,368 bytes total (1.2%)
  Bias memory:   48 bytes out of 2,048 bytes total (2.3%)
*/

